<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="build/styles.css">
<title>Using TDD to Construct Queue</title>
</head>
<body>
	<nav id="navbar">
		<header><h1>Using TDD to Construct Queue</h1></header>
		<div class="nav-links">
		<a class="nav-link" href="#Introduction">Introduction</a>
		<a class="nav-link" href="#What_is_Pytest">What is Pytest</a>
		<a class="nav-link" href="#What_is_queue">What is queue</a>
		<a class="nav-link" href="#Constructing_the_is_empty_method">Constructing the is_empty method</a>
		<a class="nav-link" href="#Constructing_the_enqueue_method">Constructing the enqueue method</a>
		<a class="nav-link" href="#Constructing_the_size_method">Constructing the size method</a>
		<a class="nav-link" href="#Constructing_the_peek_method">Constructing the peek method</a>
		<a class="nav-link" href="#Constructing_the_dequeue_method">Constructing the dequeue method</a>
		<a class="nav-link" href="#Refactoring_for_better_runtime">Refactoring for better runtime</a>
		</div>
	</nav>

	<main id="main-doc">
		<section id="Introduction" class="main-section">
			<header><h2>Introduction</h2></header>
			<p><a href="https://en.wikipedia.org/wiki/Test-driven_development">Wikipedia's entry for test driven development</a> says the following:</p>
			<blockquote>Test-driven development is a software development process that relies on the repetition of a very short development cycle: requirements are turned into very specific test cases, then the software is improved to pass the new tests, only.</blockquote>
			<p>The sections below demonstrates test-driven development (TDD) by constructing a very simple data structure called queue in Python.</p>
	</section><hr/>
	<section id="What_is_Pytest" class="main-section">
			<header><h2>What is Pytest</h2></header>
			<p>Pytest is a popular testing framework that allows you to easily write tests.</p>
			<h3>Example: hello.py</h3>
			<p> Here is a simple program: </p>
			<div class="code-block">
			<p>hello.py</p>
			<code>
				<ul><li>def hello_name(name):</li> 
					<li><ul>
							<li>return f'hello {name}!'</li>
						</ul></li>
				</ul>
			</code>
			</div>
			<p><code>test_hello.py</code> is a test for <code>hello.py</code>.</p>	

			<div class="code-block">
			<p>test_hello.py</p>
			<code>
				<ul>
					<li>from hello import hello_name</li>
					<li><br/></li>
					<li>def test_hello_name(name):</li>
					<li><ul><li>assert hell_name('bob') == 'hello bob'</li></ul></li>
		</ul>
			</code>
			</div>
			<p>To run the test above, run the following command on the command line:</p>
			<div class="command-line"><code>
					pytest test_hello.py
				</code></div>
			<p><span class="note">Note:</span> All test functions should have 'test_' as the first 5 chars of the name.</p>
			<p>For more details regarding Pytest, including installation instructions, please check <a href="https://docs.pytest.org/en/latest/">pytest's documentation page.</a>
	</section><hr/>
	<section id="What_is_queue" class="main-section">
			<header><h2>What is queue</h2></header>
			<p>Queue is a data structure whih follows the <span class="first-letter">First-In-First-Out</span> paradigm.</p>
			<p>In our construction, the <code>Queue</code> class will have the following methods:</p>
			<ul>
				<li><code>is_empty()</code>: check whether my queue is empty or not</li>
				<li><code>size()</code>: size of the queue.</li>
				<li><code>enqueue(x)</code>: add “x” to the queue</li>
				<li><code>peek()</code>: return the item at the “head” of the queue without making any changes to the queue itself</li>
				<li><code>dequeue()</code>: remove the item at the “head” of the queue and return it</li>
			</ul>
			<p>In other words, <code>queue.py</code> will start out looking like this:</p>
			<div class="code-block">
				<p>queue.py</p>
				<code><ul>
					<li>class Queue:</li>
					<li><br/></li>
					<li>def __init__(self):</li>
					<li><ul><li>pass</li></ul></li>
					<li><br/></li>
					<li>def is_empty(self):</li>
					<li><ul><li>pass</li></ul></li>
					<li><br/></li>
					<li>def size(self):</li>
					<li><ul><li>pass</li></ul></li>
					<li><br/></li>						
					<li>def enqueue(self, x):</li>
					<li><ul><li>pass</li></ul></li>
					<li><br/></li>						
					<li>def peek(self):</li>
					<li><ul><li>pass</li></ul></li>
					<li><br/></li>						
					<li>def dequeue(self):</li>
					<li><ul><li>pass</li></ul></li>
					</ul></code>
			</div>
			<p>All methods listed above should have a runtime of <code>O(1)</code>.</p>
	</section><hr/>
	<section id="Constructing_the_is_empty_method" class="main-section">
		<header><h2>Constructing the is_empty method</h2></header>
		<p>When a queue is created, the queue should be empty.</p>
		<div class="code-block">
			<p>test_queue.py</p>
			<code><ul>
					<li>from queue import Queue</li>
					<li><br/></li>					
					<li>def test_is_empty():</li>
					<li>
						<ul>
							<li>new_queue = Queue()</li>
							<li>assert new_queue.is_empty == True</li>
						</ul></li>
				</ul></code>
		</div>
		
		<p><code>test_is_empty</code> is not much right now, but more lines will get added as other methods are implemented. For now, we should just focus on defining the simplest <code>is_empty</code> emthod that will pass the test. And this can be done very easily:</p>	
		<div class="code-block">
			<p>queue.py</p>
			<code>
				<ul>
					<li>def is_empty(self):</li>
					<li><ul>
							<li>return True</li>
						</ul></li>
				</ul>
			</code>
		</div>
		<br/>
	</section><hr/>
		<section id="Constructing_the_enqueue_method" class="main-section">
			<header><h2>Constructing the enqueue method</h2></header>
			<p>When an item is added to a queue with enqueue, the queue is no longer empty.</p>
			<p><code>test_is_empty()</code> can be updated as follows:</p>
			<div class="code-block">
				<p>test_queue.py</p>
				<code><ul>
					<li>def test_is_empty():</li>
					<li>
						<ul>
							<li>new_queue = Queue()</li>
							<li>assert new_queue.is_empty == True</li>
							<li>new_queue.enqueue(1)</li>
							<li>assert new_queue.is_empty == False</li>
							<li>new_queue.enqueue(2)</li>
							<li>assert new_queue.is_empty == False</li>
						</ul>
					</li>
					</ul>
				</code>
			</div>

			<p>The following passes all the tests we have so far.</p>	
			<div class="code-block">
				<p>queue.py</p>
				<code><ul>
						<li>def __init__(self):</li>
						<li>
							<ul>
								<li>self.is_empty = True</li>
							</ul>
						</li>
						<li><br/></li>
						<li>def is_empty(self):</li>
						<li>
							<ul>
								<li>return self.is_empty</li></ul>
						</li>
						<li><br/></li>
						<li>def enqueue():</li>
						<li>
							<ul>
								<li>self.is_empty = False</li>
							</ul>
						</li>
					</ul>
				</code>
			</div>
			<br/>
		</section><hr/>
		<section id="Constructing_the_size_method" class="main-section">
			<header><h2>Constructing the size method</h2></header>
			<p>The size of the queue should start out 0, then increment by 1 each time enqueue is called.</p>
			<p>In fact, most of <code>test_size()</code> can be copied from <code>test_is_empty()</code>:</p>
			<div class="code-block">
				<p>test_queue.py</p>
				<code><ul>
						<li>def test_size():</li>
						<li><ul>
						<li>new_queue = Queue()</li>
						<li>assert new_queue.size() == 0</li>
						<li>new_queue.enqueue("x")</li>
						<li>assert new_queue.size() == 1</li>
						<li>new_queue.enqueue("x")</li>
						<li>assert new_queue.size() == 2</li>
							</ul></li>
					</ul></code>
			</div>

			<p>The <code>Queue</code> class must be updated to keep track of the number of items <code>enqueue()</code> is called:</p>	
			<div class="code-block">
				<p>queue.py</p>
				<code><ul>
						<li>def __init__(self):</li>
						<li><ul>	
						<li>self.is_empty = True</li>
						<li>self.count = 0</li></ul>
						</li>
						<li><br/></li>
						<li>def is_empty(self):</li>
						<li><ul><li>return self.is_empty</li></ul></li>
						<li><br/></li>
						<li>def enqueue(self, x):</li>
						<li><ul>
						<li>self.is_empty = False</li>
						<li>self.count += 1</li></ul></li>
						<li><br/></li>
						<li>def size(self):</li>
						<li><ul><li>return self.count</li></ul></li>
							</ul></code>
			</div>

			<p>While the current code works perfectly fine, <code>queue.py</code> can be refactored as follows:</p>
			<div class="code-block">
				<p>queue.py</p>
				<code>
					<ul>
					<li>def __init__(self):</li>
					<li><ul><li>self.count = 0</li></ul></li>
					<li><br/></li>
					<li>def is_empty(self):</li>
					<li><ul><li>return self.count == 0</li></ul></li>
					<li><br/></li>
					<li>def enqueue(self, x):</li>
					<li><ul><li>self.count += 1</li></ul></li>
					<li><br/></li>
					<li>def size(self):</li>
					<li><ul><li>return self.count</li></ul></li>
					</ul>
				</code>
			</div>
		</section>
		<br/>
		<hr/>
		<section id="Constructing_the_peek_method" class="main-section">
			<header><h2>Constructing the peek method</h2></header>
			<p><code>peek()</code> should return the head.</p>
			<div class="code-block">
				<p>test_queue.py</p>
				<code><ul>
						<li>def test_peek():</li>
						<li><ul>
							<li>new_queue = Queue()</li>
							<li>new_queue.enqueue("x")</li>
							<li>assert new_queue.peek() == "x"</li>
							<li>new_queue.enqueue("y")</li>
							<li>assert new_queue.peek() == "x"</li>
							<li>new_queue.enqueue("z")</li>
							<li>assert new_queue.peek() == "x"</li>
							</ul></li>
					</ul></code>
			</div>

			<p>Here are the corresponding changes to the <code>Queue</code> class:</p>	
			<div class="code-block">
				<p>queue.py</p>
				<code><ul>
						<li>def __init__(self):</li>
						<li><ul>
								<li>self.count = 0</li>
								<li>self.head = None</li>
							</ul></li>
						<li><br/></li>
						<li>def enqueue(self, x):</li>
						<li><ul>
								<li>self.count += 1</li>
								<li>self.head = x</li>
							</ul></li>
						<li><br/></li>
						<li>def peek(self):</li>
						<li><ul><li>return self.head</li></ul></li>
					</ul></code>
			</div>
			<p><span class="note">Note</span>: The constructions above ignores the edge case when the queue is empty. The reader is encouraged to handle this edge case.</p>
			<p>So far, our <code>Queue</code> lacked any semblance of what one might intuitively think as a queue&#8212;a data structure that hold multiple items. This will change with the addition of the <code>dequeue</code>.</p>
		</section><hr/>
		<section id="Constructing_the_dequeue_method" class="main-section">
			<header><h2>Constructing the dequeue method</h2></header>
			<p><code>dequeue()</code> should remove and return the head of a queue. As a result, the queue will have a new head, which is the element that was enqueued just after the original head element. For the first time, our <code>Queue</code> is required to keep track of the elements that have been added after the very first enqueue.</p>
			<p>Consequently, this means that in addition to adding <code>test_dequeue()</code>, a few upates should be made to the existing tests:
			<div class="code-block">
				<p>test_queue.py</p>
				<code><ul>
					<li>def test_is_empty():</li>
					<li><ul>
							<li>new_queue = Queue()</li>
							<li>assert new_queue.is_empty == True</li>
							<li>new_queue.enqueue(1)</li>
							<li>assert new_queue.is_empty == False</li>
							<li>new_queue.enqueue(2)</li>
							<li>assert new_queue.is_empty == False</li>
							<li>new_queue.dequeue()</li>
							<li>assert new_queue.is_empty == False</li>
							<li>new_queue.dequeue()</li>
							<li>assert new_queue.is_empty == True</li>
						</ul></li>
						<li><br/></li>						
					<li>def test_size():</li>
					<li><ul>
							<li>new_queue = Queue()</li>
							<li>assert new_queue.size() == 0</li>
							<li>new_queue.enqueue("x")</li>
							<li>assert new_queue.size() == 1</li>
							<li>new_queue.enqueue("y")</li>
							<li>assert new_queue.size() == 2</li>
							<li>new_queue.dequeue()</li>
							<li>assert new_queue.size() == 1</li>
							<li>new_queue.dequeue()</li>
							<li>assert new_queue.size() == 0</li>
						</ul></li>
						<li><br/></li>						
					<li>def test_peek():</li>
					<li>
						<ul>
						<li>new_queue = Queue()</li>
						<li>new_queue.enqueue("x")</li>
						<li>assert new_queue.peek() == "x"</li>
						<li>new_queue.enqueue("y")</li>
						<li>assert new_queue.peek() == "x"</li>
						<li>new_queue.enqueue("z")</li>
						<li>assert new_queue.peek() == "x"</li>
						<li>new_queue.dequeue()</li>
						<li>assert new_queue.peek() == "y"</li>
						<li>new_queue.dequeue()</li>
						<li>assert new_queue.peek() == "z"</li>
					 </ul>
						<li><br/></li>						
						<li>def test_dequeue():</li>
						<li><ul>
								<li>new_queue = Queue()</li>
								<li>for i in ["x", "y", "z"]:</li>
								<li><ul><li>new_queue.enqueue(i)</li></ul></li>
								<li>for i in ["x", "y", "z"]:</li>
								<li><ul><li>assert new_queue.dequeue() == i</li></ul></li>
							</ul></li>
					</ul></code>
			</div>

			<p>There are many ways to update the <code>Queue</code> class, but the simplest method would be to use a Python list.</p>
			<div class="code-block">
				<p>queue.py</p>
				<code><ul>
					<li>def __init__(self):</li>
					<li><ul>
							<li>self.count = 0</li>
							<li>self.arr = []</li>	
						</ul></li>
						<li><br/></li>						
					<li>def is_empty(self):</li>
					<li><ul><li>
								<li>return self.count == 0</li>
							</li></ul></li>
						<li><br/></li>						
					<li>def size(self):</li>
						<li><ul><li>return self.count</li></ul></li>
						<li><br/></li>						
					<li>def enqueue(self, x):</li>
					<li><ul>
							<li>self.count += 1</li>
							<li>self.arr.append(x)</li>
						</ul></li>
						<li><br/></li>						
					<li>def peek(self):</li>
						<li><ul><li>return self.arr[0]</li></ul></li>
						<li><br/></li>						
					<li>def dequeue(self):</li>
					<li><ul>
							<li>self.count -= 1</li>
							<li>return self.arr.pop(0)</li>
						</ul></li>
					</ul></code>
			</div>
			<p>There is actually no need for <code>count</code> now that we are using an array to track all the elements.</p>
			<div class="code-block">
				<p>queue.py</p>
				<code><ul>
						<li>def __init__(self):</li>
						<li><ul><li>self.arr = []</li></ul></li>	
						<li><br/></li>	
						<li>def is_empty(self):</li>
						<li><ul><li>return self.size() == 0</li></ul></li>
						<li><br/></li>
						<li>def size(self):</li>
						<li><ul><li>return len(self.arr)</li></ul></li>
						<li><br/></li>
						<li>def enqueue(self, x):</li>
						<li><ul><li>self.arr.append(x)</li></ul></li>
						<li><br/></li>
						<li>def peek(self):</li>
						<li><ul><li>return self.arr[0]</li></ul></li>
						<li><br/></li>
						<li>def dequeue(self):</li>
						<li><ul><li>return self.arr.pop(0)</li></ul></li>
					</ul></code>
			</div>
	</section>
	<br/>
	<hr/>
	<section  id="Refactoring_for_better_runtime" class="main-section">
		<header><h2>Refactoring for better runtime</h2></header>
		<p>The <code>Queue</code> class in the previous section has a performance issue with <code>dequeue()</code>. The <code>pop(0)</code> is <code>O(n)</code>, where <code>n</code> is the size of the queue. Ideally, we would like all queue operations to be <code>O(1)</code>.</p>
		<p>To do this, we can model the queue using 2 lists, one for enqueue and one for dequeue. Whenever <code>peek()</code> or <code>dequeue()</code> is called and the dequeue list is empty, the items from enqueue will be popped into the dequeue list. Below, I added a private method called <code>_transfer</code> which does exactly that.</p>
		<div class="code-block">
			<p>queue.py</p>
			<code><ul>
					<li>class Queue:</li>
					<li><br/></li>
					<li>def __init__(self):</li>
					<li><ul>
							<li>self.en_arr = []</li>	
							<li>self.de_arr = []</li>	
						</ul></li>
					<li><br/></li>
					<li>def is_empty(self):</li>
					<li><ul>
							<li>return self.size() == 0</li>
						</ul></li>
					<li><br/></li>
					<li>def size(self):</li>
					<li><ul>
							<li>return len(self.en_arr) + len(self.de_arr)</li>
						</ul></li>
					<li><br/></li>
					<li>def enqueue(self, x):</li>
					<li><ul>
							<li>self.en_arr.append(x)</li>
						</ul></li>
					<li><br/></li>
					<li>def peek(self):</li>
					<li><ul>
							<li>self._transfer()</li>
							<li>return self.de_arr[-1]</li>
						</ul></li>
					<li><br/></li>
					<li>def dequeue(self):</li>
					<li><ul>
							<li>self._transfer()</li>
							<li>return self.de_arr.pop()</li>
						</ul></li>
					<li><br/></li>
					<li>def _transfer(self):</li>
					<li><ul>
							<li>if not self.de_arr:</li>
							<li><ul>
									<li>while self.en_arr:</li>
									<li><ul>
											<li>self.de_arr.append(self.en_arr.pop())</li>
										</ul></li>
								</ul></li>
						</ul></li>
				</ul></code>
		</div>
		<p>To make sure that our new <code>Queue</code> class works the way it should, we only need to run Pytest.</p> 
	</section><hr/>
	<footer>
    <p>Copyright &#169; <time datetime="2019">2019</time> by Ki Song. All rights reserved.</p>
		<p>See code on the <a href="https://github.com/kiwisquash/fcc-product-landing">github repo</a> or <a href="https://codepen.io/kiwisquash/pen/WBPobq">codepen</a>.</p>
		<p>This page was last updated on <time datetime="2019-06-05">June 5th, 2019</time>.</p>
	</footer>
	</main>
</body>
