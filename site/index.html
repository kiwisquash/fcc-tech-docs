<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="css/styles.css">
<title>Using TDD to Construct Queue</title>
</head>
<body>
	<nav id="navbar">
		<header><h1>Using TDD to Construct Queue</h1></header>
		<div class="nav-links">
		<a class="nav-link" href="#Introduction">Introduction</a>
		<a class="nav-link" href="#What_is_test_driven_development">What is test driven development</a>
		<a class="nav-link" href="#What_is_Pytest">What is Pytest</a>
		<a class="nav-link" href="#What_is_queue">What is queue</a>
		<a class="nav-link" href="#Constructing_the_queue">Constructing the queue</a>
		<a class="nav-link" href="#Refactoring_for_better_runtime">Refactoring for better runtime</a>
		</div>
	</nav>

	<main id="main-doc"><section id="Introduction" class="main-section">
			<header><h2>Introduction</h2></header>
			<p>This article demonstrates test-driven development (TDD) by constructing a very simple data structure called queue in Python.</p>
		</section>
	<section id="What_is_test_driven_development" class="main-section">
			<header><h2>What is test driven development</h2></header>
			<p>According to wikipedia:</p>
			<blockquote>Test-driven development is a software development process that relies on the repetition of a very short development cycle: requirements are turned into very specific test cases, then the software is improved to pass the new tests, only.</blockquote>
	</section>
	<section id="What_is_Pytest" class="main-section">
			<header><h2>What is Pytest</h2></header>
			<p>Pytest is a popular testing framework that allows you to easily write tests.</p>
			<h3>Example: hello.py</h3>
			<p> Here is a simple program: </p>
			<div class="code-block">
			<p>hello_name.py</p>
			<code>def hello_name(name): 
    return f'hello {name}!'
			</code>
			</div>
			<p>The <code>test_hello_name.py</code> is a test for <code>hello.py</code>.</p>	

			<div class="code-block">
			<p>test_hello_name.py</p>
			<code>from hello import hello_name

def test_hello_name(name):
    assert hell_name('bob') == 'hello bob'
			</code>
			</div>
			<p>To run the test above, run the following command on the command line:</p>
			<code>
				pytest test_hello.py
			</code>
			<p><span class="note">Note:</span> All test functions should have 'test_' as the first 5 chars of the name.</p>
			<p>For more details regarding Pytest, including installation instructions, please check <a href="https://docs.pytest.org/en/latest/">pytest's documentation page.</a>
	</section>
	<section id="What_is_queue" class="main-section">
			<header><h2>What is queue</h2></header>
			<p>Queue is a data structure whih follows the <span class="first-letter">First-In-First-Out</span> paradigm.</p>
			<p>In our construction, the <code>Queue</code> class will have the following methods:</p>
			<ul>
				<li><code>is_empty()</code>: check whether my queue is empty or not</li>
				<li><code>size()</code>: size of the queue.</li>
				<li><code>enqueue(x)</code>: add “x” to the queue</li>
				<li><code>peek()</code>: return the item at the “head” of the queue without making any changes to the queue itself</li>
				<li><code>dequeue()</code>: remove the item at the “head” of the queue and return it</li>
			</ul>
			<p>In other words, <code>queue.py</code> will start out looking like this:</p>
			<div class="code-block">
				<p>queue.py</p>
				<code>class Queue:

def __init__(self):
    pass

def is_empty(self):
    pass

def size(self):
    pass

def enqueue(self, x):
    pass

def peek(self):
    pass

def dequeue(self):
    pass</code>
			</div>
			<p>All methods listed above should have a runtime of <code>O(1)</code>.</p>
	</section>
	<section id="Constructing_the_queue" class="main-section">
		<header><h2>Constructing the queue</h2></header>
		<div class="sub-section">
		<h3>is_empty(self)</h3>
		<p>When a queue is created, the queue should be empty.</p>
		<div class="code-block">
			<p>test_queue.py</p>
			<code>from queue import Queue

def test_is_empty():
    new_queue = Queue()
    assert new_queue.is_empty == True</code>
		</div>
		
		<p><code>test_is_empty</code> is not much right now, but more lines will get added as other methods are implemented. For now, we should just focus on defining the simplest <code>is_empty</code> emthod that will pass the test. And this can be done very easily:</p>	
		<div class="code-block">
			<p>queue.py</p>
			<code>def is_empty(self):
    return True
			</code>
		</div>
		</div>
		<div class="sub-section">
		<h3>enqueue()</h3>
		<p>When an item is added to a queue with enqueue, the queue is no longer empty.</p>
		<p><code>test_is_empty()</code> can be updated as follows:</p>
		<div class="code-block">
			<p>test_queue.py</p>
			<code>def test_is_empty():
    new_queue = Queue()
    assert new_queue.is_empty == True
    new_queue.enqueue(1)
    assert new_queue.is_empty == False
    new_queue.enqueue(2)
    assert new_queue.is_empty == False
</code>
</div>
		
		<p>The following passes all the tests we have so far.</p>	
		<div class="code-block">
			<p>queue.py</p>
			<code>def __init__(self):
    self.is_empty = True

def is_empty(self):
    return self.is_empty

def enqueue():
    self.is_empty = False</code>
		</div>
		
		</div>
		<div class="sub-section">
		<h3>size()</h3>
			<p>The size of the queue should start out 0, then increment by 1 each time enqueue is called.</p>
			<p>In fact, most of <code>test_size()</code> can be copied from <code>test_is_empty()</code>:</p>
			<div class="code-block">
				<p>test_queue.py</p>
				<code>...
def test_size():
    new_queue = Queue()
    assert new_queue.size() == 0
    new_queue.enqueue("x")
    assert new_queue.size() == 1
    new_queue.enqueue("x")
    assert new_queue.size() == 2
				</code>
			</div>
			
			<p>The <code>Queue</code> class must be updated to keep track of the number of items <code>enqueue()</code> is called:</p>	
			<div class="code-block">
				<p>queue.py</p>
				<code>def __init__(self):
    self.is_empty = True
    self.count = 0

def is_empty(self):
    return self.is_empty

def enqueue(self, x):
    self.is_empty = False
    self.count += 1

def size(self):
    return self.count</code>
			</div>
			
			<p>While the current code works perfectly fine, <code>queue.py</code> can be refactored as follows:</p>
			<div class="code-block">
				<p>queue.py</p>
				<code>def __init__(self):
    self.count = 0

def is_empty(self):
    return self.count == 0

def enqueue(self, x):
    self.count += 1

def size(self):
    return self.count</code>
			</div>
		</div>
		<div class="sub-section">
			<h3>peek()</h3>
			<p><code>peek()</code> should return the head.</p>
				<div class="code-block">
					<p>test_queue.py</p>
					<code>...
def test_peek():
    new_queue = Queue()
    new_queue.enqueue("x")
    assert new_queue.peek() == "x"
    new_queue.enqueue("y")
    assert new_queue.peek() == "x"
    new_queue.enqueue("z")
    assert new_queue.peek() == "x"</code>
				</div>
				
				<p>Here are the corresponding changes to the <code>Queue</code> class:</p>	
				<div class="code-block">
					<p>queue.py</p>
					<code>...

def __init__(self):
    self.count = 0
    self.head = None

def enqueue(self, x):
    self.count += 1
    self.head = x

def peek(self):
    return self.head

...</code>
			</div>
			<p><span class="note">Note</span>: The constructions above ignores the edge case when the queue is empty. The reader is encouraged to handle this edge case.</p>
<p>So far, our <code>Queue</code> lacked any semblance of what one might intuitively think as a queue&#8212;a data structure that hold multiple items. This will change with the addition of the <code>dequeue</code>.</p>
		</div>
		<div class="sub-section">
			<h3>dequeue()</h3>
			<p><code>test_dequeue()</code> should remove and return the head of a queue. As a result, the queue will have a new head, which is the element that was enqueued just after the original head element. For the first time, our <code>Queue</code> is required to keep track of the elements that have been added after the very first enqueue.</p>
			<p>Consequently, this means that in addition to adding <code>test_dequeue()</code>, a few upates should be made to the existing tests:
				<div class="code-block">
					<p>test_queue.py</p>
					<code>def test_is_empty():
    new_queue = Queue()
    assert new_queue.is_empty == True
    new_queue.enqueue(1)
    assert new_queue.is_empty == False
    new_queue.enqueue(2)
    assert new_queue.is_empty == False
    new_queue.dequeue()
    assert new_queue.is_empty == False
    new_queue.dequeue()
    assert new_queue.is_empty == True

def test_size():
    new_queue = Queue()
    assert new_queue.size() == 0
    new_queue.enqueue("x")
    assert new_queue.size() == 1
    new_queue.enqueue("y")
    assert new_queue.size() == 2
    new_queue.dequeue()
    assert new_queue.size() == 1
    new_queue.dequeue()
    assert new_queue.size() == 0

def test_peek():
    new_queue = Queue()
    new_queue.enqueue("x")
    assert new_queue.peek() == "x"
    new_queue.enqueue("y")
    assert new_queue.peek() == "x"
    new_queue.enqueue("z")
    assert new_queue.peek() == "x"
    new_queue.dequeue()
    assert new_queue.peek() == "y"
    new_queue.dequeue()
    assert new_queue.peek() == "z"
						
def test_dequeue():
    new_queue = Queue()
        for i in ["x", "y", "z"]:
        new_queue.enqueue(i)
    for i in ["x", "y", "z"]:
        assert new_queue.dequeue() == i</code>
				</div>
				
				<p>There are many ways to update the <code>Queue</code> class, but the simplest method would be to use a Python list.</p>
				<div class="code-block">
					<p>queue.py</p>
					<code>
def __init__(self):
    self.count = 0
    self.arr = []	

def is_empty(self):
    return self.count == 0

def size(self):
    return self.count

def enqueue(self, x):
    self.count += 1
    self.arr.append(x)

def peek(self):
    return self.arr[0]

def dequeue(self):
    self.count -= 1
    return self.arr.pop(0)
				</code>
			</div>
			<p>There is actually on need to keep track of <code>count</code> now that we are using an array to track all the elements.</p>
			<div class="code-block">
					<p>queue.py</p>
					<code>def __init__(self):
    self.arr = []	

def is_empty(self):
    return self.size() == 0

def size(self):
    return len(self.arr)

def enqueue(self, x):
    self.arr.append(x)

def peek(self):
    return self.arr[0]

def dequeue(self):
    return self.arr.pop(0)</code>
			</div>
		</div>
	</section>
	<section  id="Refactoring_for_better_runtime" class="main-section">
		<header><h2>Refactoring for better runtime</h2></header>
		<p>The <code>Queue</code> class in the previous section has a performance issue with <code>dequeue()</code>. The <code>pop(0)</code> is <code>O(n)</code>, where <code>n</code> is the size of the queue. Ideally, we would like all queue operations to be <code>O(1)</code>.</p>
		<p>To do this, we can model the queue using 2 lists, one for enqueue and one for dequeue. Whenever <code>peek()</code> or <code>dequeue()</code> is called and the dequeue list is empty, the items from enqueue will be popped into the dequeue list. Below, I added a private method called <code>_transfer</code> which does exactly that.</p>
		<div class="code-block">
			<p>queue.py</p>
		<code>def __init__(self):
    self.en_arr = []	
    self.de_arr = []	

def is_empty(self):
    return self.size() == 0

def size(self):
    return len(self.en_arr) + len(self.de_arr)

def enqueue(self, x):
    self.en_arr.append(x)

def peek(self):
    self._transfer()
    return self.de_arr[-1]

def dequeue(self):
    self._transfer()
    return self.de_arr.pop()

def _transfer(self):
    if not self.de_arr:
        while self.en_arr:
            self.de_arr.append(self.en_arr.pop())</code>
		</div>
		<p>To make sure that our new <code>Queue</code> class works the way it should, we only need to run Pytest.</p> 
	</section>
	<footer>
    <p>Copyright &#169; <time datetime="2019">2019</time> by Ki Song. All rights reserved.</p>
		<p>See code on the <a href="https://github.com/kiwisquash/fcc-product-landing">github repo</a> or <a href="https://codepen.io/kiwisquash/pen/zXewzO">codepen</a>.</p>
		<p>This page was last updated on <time datetime="2019-06-03">June 3rd, 2019</time>.</p>
	</footer>
	</main>
</body>
